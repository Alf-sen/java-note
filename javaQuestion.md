#### 1、面向对象与面向过程的区别

面向对象注重参与者能做些什么，面向过程注重做的顺序。面向对象有利于代码的扩展和维护，面向过程更简单直接。

例如洗衣服

* 面向过程：人打开洗衣机放入衣服->洗衣机洗衣服->洗衣机烘干->人取出衣服->人晾衣服

* 面向对象：
  * 人：打开洗衣机放衣服、取出衣服、晾衣服
  * 洗衣机：洗衣服、烘干衣服

面向对象的三大特性：

* 封装
  * 不注重如何实现，只关注能干什么。例如mybatis把数据库的增删改查都封装起来，我们直接调用方法就行。

* 继承
  * 子类继承父类的共通，让后增加自己的实现，可以扩展父类
* 多态
  * 必须有继承
  * 必须重写父类方法
  * 父类引用指向子类对象

#### 2、jdk、jre与jvm联系

* jdk为java开发工具，包含jre
* jre为java运行时所需环境，包含jvm
* jvm为java虚拟机

#### 3、==与.equals()区别

* ==对于基本数据类型比较的是值，对于引用类型比较的是对象内存地址
* .equals()与==的底层实现是一样的，但是大部分会进行重写，例如String类型就进行了重写，变为值比较

#### 4、final用法

* 修饰类
  * 修饰的类不能被继承

* 修饰方法
  * 修饰的方法不能被重写
* 修饰变量
  * 修饰变量要赋初始值且不能再变化

#### 5、String、StringBuffer、StringBuilder区别

* String由final修饰，不可变，每次操作都会产生新的对象
* Stringbuffer和Stringbuilder是在原对象上进行操作
* Stringbuffer由synchronize修饰，线程安全。
* 优先考虑使用Stringbuilder；当需要考虑线程安全时，使用Stringbuffer；当对象几乎不变时使用String

#### 6、重载与重写

* 重载发生在同类中，方法名相同，方法参数个数、类型、顺序不同，返回类型和访问修饰符可以相同
* 重写子类重写父类方法，方法名相同，方法参数个数、类型、顺序必须相同，返回类型和抛出异常必须小于等于父类方法，访问修饰符必须大于等于父类方法访问修饰符，父类中private修饰的方法不能重写。

#### 7、抽象类与接口的区别

* 抽象类可以由普通的成员函数，接口中方法只能定义public abstract方法，java8后可以定义静态方法和默认方法，用static和default修饰。
* 抽象类单继承，接口可以实现多个，必须把接口的所有方法都实现，当多个接口由相同的默认方法，在实现多个接口时实现类需要重写默认方法。
* 抽象类中可以由各种各样的成员变量，接口中成员变量默认都是public static final类型的

##### 扩充：

* 抽象类的设计目的是方法复用，一般是现有子类，再根据子类的共性抽取出父类。
* 接口的设计目的是对类的行为进行约束，只是约束了行为的有无，不关心具体的实现。
* 抽象类表达的时is a的关系，例如小明是一个人；接口表达is like的关系，例如飞机可以像鸟一样飞。
* 使用场景：关注事物的本质时使用抽象类，关注一个操作的时候用接口。

#### 8、list与set的区别

* list是有序的，可以重复的，可以存多个null对象；遍历时可以使用iterato逐一取值，也可以用get()方法进行下标取值。
* set是无序不可重复的，只允许一个存储一个null对象；遍历时只能使用iterator进行逐一取值。

#### 9、hashCode与equals

##### hashCode简介

​	hashCode()计算一个哈希值，返回的是一个int型的整数，用于标记对象在堆中的位置。hashCode定义在JDK中的java.Object类中，所有的java类中都有hashCode()方法。采用键值对的方法，尽快的确定对象在内存中的位置。

##### hashSet举例hashCode用处

​	在往hashSet中存对象时，防止重复对象。在存对象时，调用hashCode()返回一个值确定内存地址，看看该位置是否已经存在对象，如果不存在直接插入。如果该位置已经存在对象，调用equals()方法进行比较，如果对象相等，则不允许再插入该对象；如果两个对象不相等，则再重新进行哈希散列。利用这个方法，可以大大减少比较的过程，提高执行效率。

##### hashCode与equals关系

* 两个对象相等，hashCode()返回值一定相等，equals()返回true
* hashCod()返回值相等，两个对象不一定相等（equals()返回不一定时true）
* 重写equals()方法 hashCode()就必须重写对应的hashCode()，否则就会导致原有类功能出现问题（hashSet可以存相同的对象）
* hashCode是标记对象在堆中存储位置唯一值的，如果不重写hashCode()，堆中的两个类是不可能相等的（即使两个对象指向相同的数值）。





#### springboot的运行机制？

理论回答：
springbootapplication 说起，springbootconfiguration标注该类为配置类；
componentscan将指定包下面的需要装配的组件注册到spring容器里；
enableautoconfiguration：
auto configuration package 将主配置所在的包作为为自动配置的包进行管理； 
import 将meta-info下面spring.factories的配置的类导入到spring容器里。 
总结回答：
springboot根据配置文件，自动装配所属依赖的类，然后通过动态代理的方式将类注入到spring容器里。

#### mybatis的二级缓存怎么开启？

在mybatis的配置文件中开启二级缓存，并且在mapper.xml中打上cache标签。

#### redis缓存，如何解决雪崩（先说原因，再说怎么解决）

#### mysql索引底层数据结构是什么样的。（索引是干什么用的，底层结构是什么样的，索引优缺点，什么情况才用索引，索引失效情况，

怎么分析慢查询）

#### mysql分页查询

  limit m，n; 查询m条数据之后的n条数据。select * from dual limit 3,5;  4<= id <= 8
  m表示偏移量，初始值为0；
  n表示返回数据的最大条目；
  只有一个参数时表示返回的最大条目；
  当n为-1时表示返回从某一个偏移量到最后一条数据的记录。

#### 分页查询偏移量过大时，查询优化

   1）用子查询，先查询出偏移量的位置的索引值，再用一个索引确定返回的数据条目。（join分页，索引文件要小于数据文件，所以会快一些）
   2）分表查询